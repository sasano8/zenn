---
title: "pythonの辞書操作を極める"
emoji: "😸" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["markdown", "python"]
published: false
---

これも参考になるかも
https://gist.github.com/kemsakurai/3f2c5ad0638391e01fd687bd5fa8bd88


# はじめに
pythonにおける辞書操作は基礎的なことですが、ケースによって操作の使い分けが必要です。しかし、人により様々な方法を用いていたり、著者も毎回やり方がブレるという状況でしたので、自分なりのプラクティスをを整理するために本記事を執筆しました。

特に今回は、２つの辞書をマージする方法は分かった。でも、「キーの重複を許可しないマージを行いたい」というケースに遭遇し、それが大きな検証動機になっています。
そのついでに一通り基礎操作をまとめたので、誰かのガイドラインとして役に立てば幸いです。

# 検証環境
- python3.9.0

本記事では、python3.5以降から利用可能な構文を多く利用するため、python3.5未満のユーザーはあまり参考にならないと思います。

# 用語
本記事では以下の操作を区別し執筆しています。（これらの概念の正式名称があれば教えていただけると幸いです。）

| 用語 | 概要 |
| :---- | :---- |
| 結合 | 複数の辞書を１つにまとめる。 |
| マージ | 複数の辞書を結合し、かつ、衝突するキーに対しては後勝ちで値を上書きする。 |
| ユニオン | 複数の辞書のキーとバリューを辞書の要素として展開し、結合する。重複するキーは存在できないため、エラーとなることを想定している。[^1] |


[^1]: [pep584](https://www.python.org/dev/peps/pep-0584/)にて、ユニオンオペレーターはマージのことを指していますが、本記事におけるユニオンとはpep584のユニオンと関係ないものとしてください。（適切な単語が思い浮かびませんでした。）

# 辞書の取り扱い

## ソース辞書
結合対象の辞書として、以下２つ辞書をソースとして利用します。
```
dic1 = {"name": "bob", "age": 20}
dic2 = {"name": "mary"}
```

## 辞書をマージしたい（重複するキーは上書き）
挙動はマージとなる。Python3.5から辞書作成時にアンパック記法（\**）が利用可能。[^2]
[^2]: pep448 [リンク](https://www.python.org/dev/peps/pep-0448/)

``` python
# 方法１（python3.5から辞書作成時に展開記法が使用可能）
{**dic1, **dic2}
# => {"name": "mary", "age": 20}

# 波括弧での辞書宣言はキーが重複してようとおかまいなし。
{"name": "bob", "name": "mary"}
# => {"name": "mary"}

# 方法2
dict(dic1, **dic2)
# => {"name": "mary", "age": 20}

# 方法３（python3.9から和集合演算子が使用可能）
dic1 | dic2
# => {"name": "mary", "age": 20}

# 方法４
# ソースの辞書が更新されるため注意
dic1.update(dic2)
# => {"name": "mary", "age": 20}

# 方法５（python3.9から累算代入演算子が使用可能）
# ソースの辞書が更新されるため注意
dic1 |= dic2
# => {"name": "mary", "age": 20}
```

## 辞書をユニオンしたい（重複するキーの上書きは許容しない）

``` python
# 方法１
dict(**dic1, **dic2)
# => TypeError: func() got multiple values for keyword argument 'name'

# 方法２
# 方法１と同様に、dict関数を利用しなくとも同様の効果が得られる
def func(**kwargs):
  pass

func(**dic1, **dic2)
# => TypeError: func() got multiple values for keyword argument 'name'

# 可変長キーワード引数を持っていても、重複したキーが渡ってくることはない
def func(name, age, **kwargs):
  pass

func(**dic1, **dic2)
# => TypeError: func() got multiple values for keyword argument 'name'
```

## 辞書をコピーしたい
辞書をコピーする場合、シャローコピー（参照のコピー）とディープコピー（再帰的に値をコピーし、新たなインスタンスを作成）に注意しましょう。
シャローコピーでは、コンテナ型オブジェクト（リストや辞書など）の内部値はコピーされません。

``` python
src = {"name": "bob", "age": 20, "nest": {"name": "mary", "age": 30}}

# 方法１（シャローコピー）
# copyメソッドと同様。copyメソッドを利用しましょう。
copy1 = dict(\**src)

# 方法２（シャローコピー）
# copyメソッドと同様。copyメソッドを利用しましょう。
copy1 = dict(src)

# 方法３（シャローコピー）
copy1 = src.copy()

# 方法４（ディープコピー）
import copy
copy2 = copy.deepcopy(src)

# 結果確認
copy1["nest"]["age"] = 40
print(src)
# => {"name": "bob", "age": 20, "nest": {"name": "mary", "age": 40}}

print(copy1)
# => {"name": "bob", "age": 20, "nest": {"name": "mary", "age": 40}}

copy2["nest"]["age"] = 50
print(src)
# => {"name": "bob", "age": 20, "nest": {"name": "mary", "age": 40}}

print(copy2)
# => {"name": "bob", "age": 20, "nest": {"name": "mary", "age": 50}}
```

## 辞書からキーと値を削除したい
``` python
# 方法１
# パフォーマンス的に最も効率的です
# キーが存在しない場合は、KeyErrorが発生します
del dic1["name"]

# 方法２
# キーを削除しながら値を受け取ることができます
# キーが存在しない場合は、KeyErrorが発生します
val = dic1.pop("name")

# 方法３
# キーを削除しながら値を受け取ることができます
# キーが存在しない場合は、第２引数の値をデフォルト値として受け取ります
val = dic1.pop("a", None)
```

複数のキーを削除したい場合があると思うのでサンプルを載せておきます。
``` python
# 方法１
for key in some_keys:
  del dic1[key]

# 方法２
# ※delはリスト内包表記で利用することはできません
[dic1.pop(key, None) for key in some_keys]
```

# ガイドライン
ケースに応じて様々な実現方法がありますが、ルールなく使うと一貫性が崩れるので個人ルールを定めます。
python3.9を軸にルールを設けていますので、皆様はバージョン毎にカスタマイズしてご利用ください。

| バージョン | コード例 | 挙動 | 備考 |
| ---- | ---- | ---- | ---- |
| 3.5~ | {\**dic1, \**dic2} | 作成/マージ | 使うな |
|  | dict(\**dic1, \**dic2) | 作成/ユニオン | キーの衝突を想定しない場合に用いる |
|  | func(\**dic1, \**dic2) | 作成/ユニオン | キーの衝突を想定しない場合に用いる |
| | dict(dic1, \**dic2) | 作成/マージ | 使うな |
| 3.9~ | dic1 \| dic2 | 作成/マージ | マージしたい場合に用いる |
| 3.9~ | func(\**(dic1 \| dic2)) | 作成/マージ | 行を分けろ |
| ? | dic1.update(dic2) | 更新/マージ | updateにはマージとユニオンの意思が表現されてないため使わない |
| 3.9~ | dic1 \|= dic2 | 更新/マージ | 更新、かつ、マージしたい場合に用いる |
| | ~~dic1 += dic2~~ | ~~更新/ユニオン~~ | 更新、かつ、ユニオンに対応する操作は存在しない |
| | dict(\**dic1) | シャローコピー | copyメソッドを用いる |
| | dict(dic1) | シャローコピー | copyメソッドを用いる |
| | dic1.copy() | シャローコピー | ネストされたオブジェクトはコピーされないでいい場合に用いる |
| | copy.deepcopy(dic1) | ディープコピー | ネストされたオブジェクトまでコピーしたい場合に用いる |
| | del dic1["name"] | 削除 | 削除したい場合に用いる |
| | dic1.pop("name") | 削除 | 削除した値を受け取りたい場合に用いる |
| | dic1.pop("a", None) | 削除 | Key Errorを無視したい場合、または、Key Error時にデフォルト値を受け取りたい場合に用いる |
