---
title: "pythonの辞書マージ操作を極める"
emoji: "😸" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["markdown", "python"]
published: false
---

# はじめに
pythonにおいて辞書のマージ操作は基礎的な操作です。しかし、人の方法を参考にしようにも人により様々な方法を用いていたり、著者も毎回やり方がブレるという状況でしたので、自分なりのプラクティスをを整理するために本記事を執筆しました。

特に今回は、２つの辞書をマージする方法は分かった。でも、「キーの重複を許可しないマージを行いたい」というケースに遭遇し、それが大きな検証動機になっています。
そのようなケースはあまり多くないと思いますが、誰かの参考になれば幸いです。

# 検証環境
- python3.9.0

# 用語
本記事では以下の操作を区別し、執筆しています。（これらの概念の正式名称があれば教えていただけると幸いです。）

| 用語 | 概要 |
| :---- | :---- |
| 結合 | 複数の辞書を１つにまとめる。 |
| マージ | 複数の辞書を結合し、かつ、衝突するキーに対しては後勝ちで値を上書きする。 |
| ユニオン | 複数の辞書のキーとバリューを辞書の要素として展開し、結合する。重複するキーは存在できないため、エラーとなることを想定している。[^1] |


[^1] : (pep584)[https://www.python.org/dev/peps/pep-0584/]にて、ユニオンオペレーターはマージのことを指していますが、本記事におけるユニオンとはpep584のユニオンと関係ないものとしてください。（適切な単語が思い浮かびませんでした。）

# 辞書の取り扱い

## ソース辞書
結合対象の辞書として、以下２つ辞書をソースとして利用します。
```
dic1 = {"name": "bob", "age": 20}
dic2 = {"name": "mary"}
```

## 波括弧
挙動はマージとなる。Python3.5から辞書作成時にアンパック記法（\**）が利用可能。[^2]
[^2] : (pep448)[https://www.python.org/dev/peps/pep-0448/]

``` python
{**dic1, **dic2}
# => {"name": "mary", "age": 20}
```

ちなみに、波括弧での辞書宣言は以下のようにキーが重複してようとおかまいなし。
宣言と中身が一致しておらず、いけてない。。。
``` python
{"name": "bob", "name": "mary"}
# => {"name": "mary"}
```

## dict関数
挙動はユニオンとなる。意図は明確でないが、意図せずマージされてしまうことはない。波括弧よりdict関数を積極的に使いたい。
``` python
dict(**dic1, **dic2)
# => TypeError: func() got multiple values for keyword argument 'name'
```

## 関数呼び出し時
挙動はユニオンとなる。意図は明確でないが、意図せずマージされてしまうことはない。
``` python
def func(**kwargs):
  ...

func(**dic1, **dic2)
# => TypeError: func() got multiple values for keyword argument 'name'
```


## 可変長キーワード引数持ちの関数呼び出し時
挙動はユニオンとなる。重複したキーが、可変長キーワード引数に渡ってくる心配をする必要はない。
``` python
def func(name, age, **kwargs):
  ...

func(**dic1, **dic2)
# => TypeError: func() got multiple values for keyword argument 'name'
```

## dict関数の第一引数に辞書を渡す
挙動はマージとなる。dic1のソースが変更されることはない。
``` python
dict(dic1, **dic2)
# => {"name": "mary", "age": 20}
```

## 和集合演算子
挙動はマージとなる。和集合演算子で意図は伝わりやすいので積極的に使いたい。
``` python
dic1 | dic2
# => {"name": "mary", "age": 20}
```

## updateメソッド
挙動はマージとなる。dic1に対して破壊的変更が行われる。
``` python
dic1.update(dic2)
# => {"name": "mary", "age": 20}
```

## 累算代入演算子
挙動はマージとなる。updateと同等だが、和集合演算子（|）でマージする意図が表現されているためこちらを使っていきたい。
``` python
dic1 |= dic2
# => {"name": "mary", "age": 20}
```

# まとめ
最後に検証結果と、どの方法を用いるか個人的ルールをまとめる。
バージョンを考慮すると話がややこしくなるため、python3.9のみの考慮とする。

| バージョン | コード例 | 挙動 | 備考 |
| ---- | ---- | ---- | ---- |
| 3.5~ | {\**dic1, \**dic2} | 作成/マージ | 使うな |
|  | dict(\**dic1, \**dic2) | 作成/ユニオン | キーの衝突を想定しない場合に用いる |
|  | func(\**dic1, \**dic2) | 作成/ユニオン | キーの衝突を想定しない場合に用いる |
| | dict(dic1, \**dic2) | 作成/マージ | 使うな |
| 3.9~ | dic1 \| dic2 | 作成/マージ | マージしたい場合に用いる |
| 3.9~ | func(\**(dic1 \| dic2)) | 作成/マージ | 行を分けろ |
| ? | dic1.update(dic2) | 更新/マージ | updateにはマージとユニオンの意思が表現されてないため使わない |
| 3.9~ | dic1 \|= dic2 | 更新/マージ | 更新、かつ、マージしたい場合に用いる |
| | ~~dic1 += dic2~~ | ~~更新/ユニオン~~ | 更新、かつ、ユニオンに対応する操作は存在しない |
