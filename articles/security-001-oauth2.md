---
title: "pythonの辞書マージ操作を極める"
emoji: "😸" # アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # tech: 技術記事 / idea: アイデア記事
topics: ["markdown", "python"]
published: false
---

# OAuth2
RFF6750に登録されている認証スキームである。
OAuthは、認可サーバがクライアントに対し発行するアクセストークン（アクセス認可の文字列）を用いることで、保護リソースへのアクセスを許可する。アクセストークンは、リソース所有者の直接的なクレデンシャルを共有するものではない。

- [英語](https://tools.ietf.org/html/rfc6750)
- [日本語](http://openid-foundation-japan.github.io/rfc6750.ja.html)

## キーワード
- access token
- 認証
- 認可
- Bearer token
- jwt
- token68

# 認証
サービス利用者は、リソースオーナーにIDやパスワードを伝え、リソースオーナーはIDやパスワードなどから利用者を特定する。

# 認可
リソースオーナーは認証の結果として、サービスの利用許可とアクセス可能なリソース範囲を示すトークンを返す。
認証・認可とは、いわゆるログインのことである。

# access token
認可サーバが発行するアクセス認可の文字列。
入館証のようなものだ。

# 署名なしトークン(Bearer Token)
トークンを所有する任意のパーティ（Bearer=持参人払い）は、「トークンを所有している」という条件を満たせばトークンを利用することができる。
電車の切符のように、買った本人でなくとも利用することができる。

```
headers={"X-Token": secret_token}
```

# 現在のログイン処理
1. クライアントから、ユーザ名・パスワードを受け取り、ユーザー情報を取得する。（パスワードは、パスワードハッシュを用いる）
2. ユーザー名・アクセススコープ・有効期限情報を付与した情報をエンコードし、アクセストークンとして返す。
3. クライアントからリソースへのアクセスを要求された時、アクセストークンからユーザー名・アクセススコープをデコードし、権限に応じて処理を受け入れる。

# 疑問
- アクセストークン用のキー・バリューストア（アクセストークン・ユーザーIDのペア）は必要ないのか？
- 可能性として無視できるレベルだが、意図と異なるユーザー情報が埋め込まれた同一のハッシュを生成できる可能性がある。
- アクセストークンを復元できた場合、情報を見ることができてしまう。
- トークンには、識別子型と内包型がある。
- アクセストークンは、RFC7519で定められるJWT(JSON Web Token)が用いられることが多い。
- 識別子型は、RFC7662という標準仕様が存在する
- 内包型には、RFC6749にてアクセストークンの署名方法が記されている。
- 内包型のアクセストークンは、有効期限前にアクセストークンを失効させることが難しいと書かれた記事がある。アクセストークンに生成日時を埋め込めば可能では。
- そもそもJWTのアクセストークン自体に、仕様を利用した脆弱性があるとの声もある。

# 認証時のパラメータは以下の通りだが、これはOAuth2の仕様なのだろうか？
grant_type="password",
username=USERNAME,
password=PASSWORD,
scope=" ".join(["me", "items"]),  # 複数のスコープは、スペースで区切って指定する
client_id=None,
client_secret=None
